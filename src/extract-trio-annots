#!/usr/bin/env perl
#
# Author: petr.danecek@sanger
#


use strict;
use warnings;
use Carp;
use Data::Dumper;

my $opts = parse_params();
main($opts);

exit;

#--------------------------------

sub describe_output
{
    my $str = q[
        chr, pos, ref, alt

        proband, father, mother

        nReads_proband, nReads_father, nReads_mother
            - total number of reads in the three samples

        nAltReads_proband, nAltReads_father, nAltReads_mother
            - number of alternate reads

        DNM
            - score generated by +trio-dnm2

        DNG
            - score generated by DeNovoGear reimplementation in +trio-dnm2

        VCF_QUAL
            - variant quality as given by the QUAL column in the VCF

        VAF
            - variant allele frequency

        MaxParentalVAF
            - maximum variant allele frequency in father and mother

        SP
            - phred-scaled strand bias test as calculated by `bcftools mpileup`

        SCR
            - number of soft-clipped reads

        N_ALT
            - number of alternate alleles

        NMBZ
            - NM mismatches bias

        NMR, NMA, MAX_NMRA
            - average number of mismatches in reference and alternate reads and their maximum

        indel_length
            - negative number for deletions, positive for insertions, 0 for substitutions

        PAR_overlap
            - overlap with pseudoautosomal regions:
                GRCh37 .. X:60001-2699520,X:154931044-155270560
                GRCh38 .. chrX:10000-2781479,chrX:155701382-156030895

        gnomad_AF
            - allele frequency in gnomAD

        segdup
            - overlap with a segmental duplication

        repeat
            - overlap with repeat-masked regions, the number is % divergence

        sex
            - M or F

        inheritance
            - m, f, mf, or .: inherits only from mother ("m", e.g. has XY and is chrX), from father ("f",
              has XY and is chrY), from both ("mf", is autosomal or has XX and is chrX or has XX and is
              pseudoautosomal region of chrX), cannot inherit ("." has XX on chrY)
    ];
    $str =~ s/\n {8}/\n/g;
    $str =~ s/^\s*$/\n/;
    $str =~ s/\s*$/\n\n/;
    print $str;
    exit;
}

sub error
{
    my (@msg) = @_;
    if ( scalar @msg ) { confess @msg; }
    print
        "About: Create a master table with DNM candidates. The samples in input VCFs\n",
        "       must be in the order: proband, father, mother. For a detailed description\n",
        "       of the output, run `extract-annots --describe-output`\n",
        "Usage: extract-trio-annots [OPTIONS]\n",
        "Options:\n",
        "     -a, --allele-frequencies TAG FILE   Fill in allele frequencies using TAG from FILE (VCF/BCF)\n",
        "         --describe-output               Print a detailed description of the output\n",
        "     -d, --segmental-dups FILE           Segmental duplications (chr,beg,end); optional\n",
        " (*) -f, --fasta-reference FILE          Fasta reference file for consequence annotation\n",
        " (*) -o, --output-file FILE              Output file name\n",
        " (*) -p, --ped-file FILE                 Annotate with sex\n",
        "     -P, --PARs LIST                     List of pseudoautosomal regions, such as X:60001-2699520,X:154931044-155270560\n",
        "     -r, --repeats FILE                  Repeats (chr,beg,end,divergence); optional\n",
        " (*) -t, --trio-dnm-list FILE            Trio VCFs/BCFs to process, trio-dnm2 output (proband,father,mother)\n",
        "     -h, -?, --help                      This help message\n",
        "The options marked as (*) are mandatory\n",
        "\n";
    exit -1;
}

sub parse_params
{
    my $opts =
    {
        bcftools => 'bcftools',
        af_tag   => 'extAF',
    };
    if ( !@ARGV ) { error(); }
    while (defined(my $arg=shift(@ARGV)))
    {
        if (                 $arg eq '--dump-site' ) { $$opts{dump_site} = shift(@ARGV); next; }
        if ( $arg eq '-a' or $arg eq '--allele-frequencies' ) { $$opts{af_tag} = shift(@ARGV); $$opts{af_file} = shift(@ARGV); next; }
        if ( $arg eq '-d' or $arg eq '--segmental-dups' ) { $$opts{seg_dup} = shift(@ARGV); next; }
        if ( $arg eq '-r' or $arg eq '--repeats' ) { $$opts{repeats} = shift(@ARGV); next; }
        if ( $arg eq '-p' or $arg eq '--ped-file' ) { $$opts{ped_file} = shift(@ARGV); next; }
        if ( $arg eq '-P' or $arg eq '--PARs' )
        {
            my $pars = shift(@ARGV);
            for my $par (split(/,/,$pars))
            {
                if ( !($par=~/^([^:]+):(\d+)-(\d+)$/) ) { error("Could not parse --PARs $par"); }
                push @{$$opts{par}{$1}},[$2,$3];
            }
            next;
        }
        if ( $arg eq '-f' or $arg eq '--fasta-reference' ) { $$opts{ref} = shift(@ARGV); next; }
        if ( $arg eq '-t' or $arg eq '--trio-dnm-list' ) { $$opts{trio_dnm_files} = shift(@ARGV); next; }
        if ( $arg eq '-o' or $arg eq '--output-file' ) { $$opts{outfile} = shift(@ARGV); next; }
        if ( $arg eq '-?' or $arg eq '-h' or $arg eq '--help' ) { error(); }
        if (                 $arg eq '--describe-output' ) { describe_output($opts); next; }
        error("Unknown parameter \"$arg\". Run -h for help.\n");
    }
    if ( !exists($$opts{trio_dnm_files}) ) { error("Missing the -t, --trio-dnm-list option"); }
    if ( !exists($$opts{outfile}) ) { error("Missing the -o, --output-file option"); }
    if ( !exists($$opts{ref}) ) { error("Missing the -f, --fasta-reference option"); }
    if ( exists($ENV{BCFTOOLS}) ) { $$opts{bcftools} = $ENV{BCFTOOLS}; }
    $$opts{tmp_bcf} = "$$opts{outfile}.tmp.bcf";
    return $opts;
}

sub main
{
    my ($opts) = @_;

    extract_sites($opts);

    run_segdup($opts);
    run_repeats($opts);
    run_AFs($opts);
    run_smpl2sex($opts);

    annots_open($opts);
    open(my $fh,'<',$$opts{trio_dnm_files}) or error("$$opts{trio_dnm_files}: $!");
    while (my $file = <$fh>)
    {
        chomp($file);
        annots_process_vcf($opts,$file);
    }
    close($fh) or error("close failed: $$opts{trio_dnm_files}");
    annots_close($opts);
}

sub dump_site
{
    my ($opts) = @_;
    if ( !($$opts{dump_site}=~/^([^:]+):(.+)$/) ) { error("Could not parse the argument to --dump-site, expected: chr:pos\n"); }
    my $chr  = $1;
    my $pos  = $2;
    if ( !exists($$opts{stats}{$chr}{$pos}) ) { error("No such data point: $$opts{dump_site}\n") }
    use Data::Dumper;
    print STDERR Dumper($$opts{stats}{$chr}{$pos});
}

sub annots_close
{
    my ($opts) = @_;
    close($$opts{out_fh}) or error("close failed: $$opts{outfile}.part");
    cmd(qq[(gunzip -c $$opts{outfile}.part | grep ^#; gunzip -c $$opts{outfile}.part | grep -v ^# | sort -k1,1d -k2,2n -k3,3d -k4,4d -k5,5d | uniq) | gzip -c > $$opts{outfile}.partx]);
    rename("$$opts{outfile}.partx","$$opts{outfile}") or error("rename $$opts{outfile}.partx $$opts{outfile}: $!");
    unlink("$$opts{outfile}.part");
}
sub annots_open
{
    my ($opts) = @_;
    my @hdr = qw(chr pos ref alt
        proband father mother
        nReads_proband nReads_father nReads_mother
        nAltReads_proband nAltReads_father nAltReads_mother
        SCR_proband SCR_parents
        DNM
        DNG
        VCF_QUAL
        VAF
        MaxParentalVAF
        N_ALT SP MQBZ SCBZ NMBZ NMR NMA MAX_NMRA
        indel_length
        );
    if ( exists($$opts{par}) ) { push @hdr,'PAR_overlap'; }
    if ( exists($$opts{af_file}) ) { push @hdr,$$opts{af_tag}; }
    if ( exists($$opts{seg_dup}) ) { push @hdr,'segmental_dup'; }
    if ( exists($$opts{repeats}) ) { push @hdr,'repeat'; }
    if ( exists($$opts{ped_file}) ) { push @hdr,'sex'; }
    if ( exists($$opts{ped_file}) && exists($$opts{par}) ) { push @hdr,'inheritance'; }
    for (my $i=0; $i<@hdr; $i++)
    {
        $hdr[$i] = sprintf("[%d]%s",$i+1,$hdr[$i]);
    }
    open($$opts{out_fh},"| gzip -c > $$opts{outfile}.part") or error("gzip -c > $$opts{outfile}.part");
    print {$$opts{out_fh}} "#".join("\t",@hdr)."\n";
}
sub annots_process_vcf
{
    my ($opts,$vcf) = @_;
    my $src = (grep { chomp } `$$opts{bcftools} view -h $vcf | grep ^##source=`)[0];
    if ( !defined $src ) { $src = 'mpileup'; }
    else { $src =~ s/^##source=//; }
    my $cmd = qq[$$opts{bcftools} query -u -f'%CHROM\\t%POS\\t%REF\\t%ALT\\t%QUAL\\t%NM[\\t%SAMPLE][\\t%DNM][\\t%VAF][\\t%VA][\\t%DNG][\\t%AD][\\t%SP]\\t%MQBZ\\t%SCBZ[\\t%SCR][\\t%NMBZ]\\n' $vcf];
    print STDERR "$cmd\n";
    open(my $fh,"$cmd |") or error("$cmd: $!");
    while (my $line=<$fh>)
    {
        chomp($line);
        my ($chr,$pos,$ref_ori,$alt_ori,$qual,$nm2,
            $proband,$father,$mother,
            $dnm,undef,undef,
            $vaf,$f_vaf,$m_vaf,
            $va,undef,undef,
            $dng_dnm,undef,undef,
            $p_ad,$f_ad,$m_ad,
            $sp,undef,undef,
            $mqbz,$scbz,
            $p_scr,$f_scr,$m_scr,
            $p_nmbz,undef,undef) = split(/\t/,$line);
        if ( $va eq '.' ) { next; }
        my ($nmr,$nma) = split(/,/,$nm2);
        if ( $nm2 eq '.' or $nmr eq '.' ) { $nmr = 0; }
        if ( $nm2 eq '.' or $nma eq '.' ) { $nma = 0; }
        my $max_nmra = $nmr > $nma ? $nmr : $nma;

        # Determine the number of alternate alleles. Make sure AD=0 alts in proband are not counted
        my @alts = split(/,/,$alt_ori);
        my $n_alt = scalar @alts;
        for my $cnt (split(/,/,$p_ad)) { if ( $cnt eq '0' or $cnt eq '.' ) { $n_alt--; } }
        if ( $n_alt <= 0 ) { $n_alt = @alts; }

        for (my $i=0; $i<@alts; $i++)
        {
            if ( $va>0 && $i+1!=$va ) { next; }

            my ($ref,$alt) = trim_ref_alt($ref_ori,$alts[$i]);
            my $rlen = length($ref);
            my $alen = length($alt);
            my $indel_len = ($rlen==$alen) ? 0 : ($alen - $rlen);

            my $p_dp = vec_sum($p_ad);
            my $f_dp = vec_sum($f_ad);
            my $m_dp = vec_sum($m_ad);
            my $p_alt = vec_val($p_ad,$i+1);
            my $f_alt = vec_val($f_ad,$i+1);
            my $m_alt = vec_val($m_ad,$i+1);
            my $mf_scr = ($f_scr ne '.' && $f_scr > $m_scr) ? $f_scr : $m_scr;

            if ( $va==0 )
            {
                $p_alt = $p_dp - $p_alt;
                $m_alt = $m_dp - $m_alt;
                $f_alt = $f_dp - $f_alt;
            }

            my $key = join("\t",$chr,$pos,$ref,$alt);
            my $idx = exists($$opts{variant2idx}) && exists($$opts{variant2idx}{$key}) ? $$opts{variant2idx}{$key} : undef;
            my $max_parental_vaf = $f_vaf > $m_vaf ? $f_vaf : $m_vaf;

            my @out;
            push @out,$chr,$pos,$ref,$alt;
            push @out,$proband,$father,$mother;
            push @out,$p_dp,$f_dp,$m_dp;
            push @out,$p_alt,$f_alt,$m_alt;
            push @out,$p_scr,$mf_scr;
            push @out,$dnm;
            push @out,$dng_dnm;
            push @out,$qual;
            push @out,$vaf;
            push @out,$max_parental_vaf;
            push @out,$n_alt;
            push @out,$sp;
            push @out,$mqbz;
            push @out,$scbz;
            push @out,$p_nmbz;
            push @out,$nmr,$nma,$max_nmra;
            push @out,$indel_len;
            my ($is_par,$sex);
            if ( exists($$opts{par}) )
            {
                $is_par = region_overlap($$opts{par},$chr,$pos);
                push @out,$is_par;
            }
            if ( exists($$opts{af_file}) ) { push @out,(exists($$opts{variant2af}{$key}) ? $$opts{variant2af}{$key} : 0); }
            if ( exists($$opts{seg_dup}) ) { push @out,(exists($$opts{variant2segdup}{$key}) ? $$opts{variant2segdup}{$key} : 0); }
            if ( exists($$opts{repeats}) ) { push @out,(exists($$opts{variant2repeat}{$key}) ? $$opts{variant2repeat}{$key} : 0); }
            if ( exists($$opts{ped_file}) )
            {
                $sex = $$opts{smpl2sex}{$proband};
                push @out,$sex;
            }
            if ( exists($$opts{par}) && exists($$opts{ped_file}) )
            {
                my $inheritance = 'mf';
                if ( $sex eq 'M' )
                {
                    if ( ($chr eq 'X' or $chr eq 'chrX') and !$is_par ) { $inheritance = 'm'; }
                    if ( ($chr eq 'Y' or $chr eq 'chrY') ) { $inheritance = 'f'; }
                }
                if ( $sex eq 'F' )
                {
                    if ( ($chr eq 'Y' or $chr eq 'chrY') ) { $inheritance = '.'; }
                }
                push @out,$inheritance;
            }
            print {$$opts{out_fh}} join("\t",@out)."\n";
        }
    }
    close($fh) or error("close failed: $cmd");
}
sub vec_val
{
    my ($vec,$idx) = @_;
    my @val = split(/,/,$vec);
    if ( !exists($val[$idx]) )
    {
        if ( $vec eq '.' ) { return 0; }
        error("Uh: vec=[$vec] idx=$idx\n");
    }
    return $val[$idx];
}
sub vec_sum
{
    my ($vec) = @_;
    my @val = split(/,/,$vec);
    my $sum = 0;
    for my $val (@val)
    {
        if ( $val eq '.' ) { next; }
        $sum += $val;
    }
    return $sum;
}
sub region_overlap
{
    my ($regs,$chr,$pos) = @_;
    if ( !exists($$regs{$chr}) ) { return 0; }
    for my $reg (@{$$regs{$chr}})
    {
        if ( $$reg[0] <= $pos && $pos <= $$reg[1] ) { return 1; }
    }
    return 0;
}

sub trim_ref_alt
{
    my ($ref,$alt) = @_;
    while ( length($ref)>1 && length($alt)>1 )
    {
        if ( substr($ref,-1) ne substr($alt,-1) ) { last; }
        substr($alt,-1,1,'');
        substr($ref,-1,1,'');
    }
    return ($ref,$alt);
}

sub round_value
{
    my ($tick, $value) = @_;
    my $rounded = $tick * int($value/$tick);
    if ( $value - $rounded > $tick*0.5 ) { $rounded += $tick; }
    return $rounded;
}
sub extract_parental_vaf
{
    my ($opts,$out,$file) = @_;
    my $cmd = $$opts{bcftools}.q[ query -f "%CHROM\t%POS\t%REF\t%ALT[\t%AD]\n" ].$file;
    my %prev = ();
    open(my $fh,"$cmd |") or error("$cmd: $!");
    while (my $line=<$fh>)
    {
        chomp($line);
        my ($chr,$pos,$ref,$alt,$f_ad,$m_ad) = split(/\t/,$line);
        my @alts = split(/,/,$alt);
        my @ads  = ([split(/,/,$f_ad)],[split(/,/,$m_ad)]);
        for (my $i=0; $i<@alts; $i++)
        {
            if ( $alts[$i] eq '.' or $alts[$i] eq '<*>' ) { next; }     # REF-only site

            my ($norm_ref,$norm_alt) = trim_ref_alt($ref,$alts[$i]);
            my $key = "$chr\t$pos\t$norm_ref\t$norm_alt";

            # Duplicate keys, this can sometimes occur after normalization at multiallelic site followed by a
            # biallelic site. Make sure not to count multiple times.
            if ( exists($prev{$key}) ) { next; }
            $prev{$key} = 1;

            for (my $j=0; $j<2; $j++)   # father,mother
            {
                my $nref = $ads[$j][0];
                my $nalt = $ads[$j][1+$i];
                if ( $nref + $nalt < 20 ) { next; }
                my $vaf  = $nref+$nalt ? $nalt/($nalt+$nref) : 0;

                # Recurrent sites often have parental VAF~1, flipping was making them look normal
                #   if ( $vaf > 0.5 ) { $vaf = 1 - $vaf; }

                $vaf = round_value($$opts{vaf_bin_size}, $vaf);
                if ( $vaf )
                {
                    print $out $key."\t$vaf\t$file\n";
                }
            }
        }
    }
    close($fh) or error("close failed: $cmd");
}

sub run_segdup
{
    my ($opts,$sites) = @_;

    if ( !exists($$opts{seg_dup}) ) { return; }

    my $cmd = qq[$$opts{bcftools} annotate -a $$opts{seg_dup} -c CHROM,BEG,END -m SEG_DUP $$opts{tmp_bcf} | $$opts{bcftools} query -f'%CHROM\\t%POS\\t%REF\\t%ALT\\t%SEG_DUP\\n'];
    print STDERR "$cmd\n";
    open(my $fh,"$cmd |") or error("$cmd: $!");
    while (my $line=<$fh>)
    {
        chomp($line);
        my ($chr,$pos,$ref,$alt,$sdup) = split(/\t/,$line);
        if ( $sdup eq '.' ) { next; }
        my $key = join("\t",$chr,$pos,$ref,$alt);
        $$opts{variant2segdup}{$key} = 1;
    }
    close($fh) or error("close failed: $cmd");
}

sub run_repeats
{
    my ($opts,$sites) = @_;

    if ( !exists($$opts{repeats}) ) { return; }

    my $cmd = qq[$$opts{bcftools} annotate -a $$opts{repeats} -c CHROM,BEG,END,REPEAT -H '##INFO=<ID=REPEAT,Number=1,Type=Float,Description="Repeat Region % Divergence">' $$opts{tmp_bcf} | $$opts{bcftools} query -f'%CHROM\\t%POS\\t%REF\\t%ALT\\t%REPEAT\\n'];
    print STDERR "$cmd\n";
    open(my $fh,"$cmd |") or error("$cmd: $!");
    while (my $line=<$fh>)
    {
        chomp($line);
        my ($chr,$pos,$ref,$alt,$repeat) = split(/\t/,$line);
        if ( $repeat eq '.' ) { next; }
        my $key = join("\t",$chr,$pos,$ref,$alt);
        $$opts{variant2repeat}{$key} = $repeat;
    }
    close($fh) or error("close failed: $cmd");
}

sub run_AFs
{
    my ($opts,$sites) = @_;

    if ( !exists($$opts{af_file}) ) { return; }

    my $cmd = qq[$$opts{bcftools} annotate -a $$opts{af_file} -c $$opts{af_tag} $$opts{tmp_bcf} | $$opts{bcftools} query -f'%CHROM\\t%POS\\t%REF\\t%ALT\\t%$$opts{af_tag}\\n'];
    print STDERR "$cmd\n";
    open(my $fh,"$cmd |") or error("$cmd: $!");
    while (my $line=<$fh>)
    {
        chomp($line);
        my ($chr,$pos,$ref,$alt,$af) = split(/\t/,$line);
        if ( $af eq '.' ) { next; }
        my $key = join("\t",$chr,$pos,$ref,$alt);
        $$opts{variant2af}{$key} = $af;
    }
    close($fh) or error("close failed: $cmd");
}
sub run_smpl2sex
{
    my ($opts) = @_;
    if ( !exists($$opts{ped_file}) ) { return; }
    open(my $fh,'<',$$opts{ped_file}) or error("$$opts{ped_file}: $!");
    while (my $line=<$fh>)
    {
        chomp($line);
        my @col = split(/\t/,$line);
        my $sex = '.';
        if ( $col[4] eq '1' ) { $sex = 'M'; }
        elsif ( $col[4] eq '2' ) { $sex = 'F'; }
        else { print STDERR "sex code not recognized in $$opts{ped_file}: $line"; }
        $$opts{smpl2sex}{$col[1]} = $sex;
    }
    close($fh) or error("close failed: $$opts{ped_file}");
}
sub cmp_chr_pos_key
{
    my $ret;
    my @a = split(/\t/,$a);
    my @b = split(/\t/,$b);
    $ret = $a[0] cmp $b[0];
    if ( $ret ) { return $ret }
    $ret = $a[1] <=> $b[1];
    if ( $ret ) { return $ret }
    $ret = $a[2] cmp $b[2];
    if ( $ret ) { return $ret }
    return $a[3] cmp $b[3];
}
sub extract_sites
{
    my ($opts) = @_;
    my @idx2variant  = ();
    my %variant = ();
    my %chrs = ();
    open(my $fh,'<',$$opts{trio_dnm_files}) or error("$$opts{trio_dnm_files}: $!");
    while (my $file = <$fh>)
    {
        for my $line (`$$opts{bcftools} query -f'%CHROM %POS %REF %ALT' $file`)
        {
            chomp($line);
            my ($chr,$pos,$ref,$alt) = split(/ /,$line);
            my $key = join("\t",$chr,$pos,$ref,$alt);
            $variant{$key} = 1;
            $chrs{$chr} = 1;
        }
    }
    close($fh) or error("close failed: $$opts{trio_dnm_files}");
    for my $key (sort cmp_chr_pos_key keys %variant)
    {
        push @idx2variant,$key;
    }
    $$opts{idx2variant}  = \@idx2variant;
    $$opts{contigs} = \%chrs;
}

sub cmd
{
    my ($cmd,%args) = @_;

    if ( !exists($args{verbose}) ) { $args{verbose} = 1; }
    if ( $args{verbose} ) { print STDERR $cmd,"\n"; }

    # Why not to use backticks? Perl calls /bin/sh, which is often bash. To get the correct
    #   status of failing pipes, it must be called with the pipefail option.

    my $kid_io;
    my $pid = open($kid_io, "-|");
    if ( !defined $pid ) { error("Cannot fork: $!"); }

    my @out;
    if ($pid)
    {
        # parent
        @out = <$kid_io>;
        close($kid_io);
    }
    else
    {
        # child
        exec('/bin/bash', '-o','pipefail','-c', $cmd) or error("Failed to run the command [/bin/sh -o pipefail -c $cmd]: $!");
    }

    if ( exists($args{exit_on_error}) && !$args{exit_on_error} ) { return @out; }

    my $exit_status = $?;
    my $status = exists($args{require_status}) ? $args{require_status} : 0;
    if ( $status ne $exit_status )
    {
        my $msg;
        if ( $? & 0xff )
        {
            $msg = "The command died with signal ".($? & 0xff);
        }
        else
        {
            $msg = "The command exited with status ".($? >> 8)." (expected $status)";
        }
        $msg .= ":\n\t$cmd\n\n";
        if ( @out ) {  $msg .= join('',@out,"\n\n"); }
        error($msg);
    }
    return @out;
}


#---------------------------
package Binom;

# Accuracy of this implementation compared to R:
#      avg diff = 6.6e-10
#      std_dev  = 4.4e-09
#      max_diff = 5.0e-08

use strict;
use warnings;
use Carp;

sub Binom::kf_lgamma
{
    my ($z) = @_;
    my $x = 0;
    $x += 0.1659470187408462e-06 / ($z+7);
    $x += 0.9934937113930748e-05 / ($z+6);
    $x -= 0.1385710331296526     / ($z+5);
    $x += 12.50734324009056      / ($z+4);
    $x -= 176.6150291498386      / ($z+3);
    $x += 771.3234287757674      / ($z+2);
    $x -= 1259.139216722289      / ($z+1);
    $x += 676.5203681218835      / $z;
    $x += 0.9999999999995183;
    return log($x) - 5.58106146679532777 - $z + ($z-0.5) * log($z+6.5);
}
sub Binom::kf_betai_aux
{
    my ($a,$b,$x) = @_;
    my ($C, $D, $f);
    my $j;
    if ($x == 0) { return 0; }
    if ($x == 1) { return 1; }
    $f = 1.; $C = $f; $D = 0.;

    my $kf_tiny  = 1e-290;
    my $kf_gamma_eps = 1e-14;

    # Modified Lentz's algorithm for computing continued fraction
    for ($j = 1; $j < 200; ++$j)
    {
        my ($aa, $d);
        my $m = $j>>1;
        $aa = ($j&1) ? -($a + $m) * ($a + $b + $m) * $x / (($a + 2*$m) * ($a + 2*$m + 1)) : $m * ($b - $m) * $x / (($a + 2*$m - 1) * ($a + 2*$m));
        $D = 1. + $aa * $D;
        if ($D < $kf_tiny) { $D = $kf_tiny; }
        $C = 1. + $aa / $C;
        if ($C < $kf_tiny) { $C = $kf_tiny; }
        $D = 1. / $D;
        $d = $C * $D;
        $f *= $d;
        if (abs($d - 1.) < $kf_gamma_eps) { last; }
    }
    return exp(kf_lgamma($a+$b) - kf_lgamma($a) - kf_lgamma($b) + $a * log($x) + $b * log(1.-$x)) / $a / $f;
}
sub Binom::kf_betai
{
    my ($a,$b,$x) = @_;
    return ($x < ($a + 1.) / ($a + $b + 2.)) ? kf_betai_aux($a, $b, $x) : 1. - kf_betai_aux($b, $a, 1. - $x);
}
sub Binom::test
{
    my ($na,$nb,$exp,$alt,%args) = @_;
    my $prob = 1;
    if ( $alt eq 'g' && $na>0 )
    {
        $prob = kf_betai($na, $nb + 1, $exp);
    }
    elsif ( $alt eq 'l' && $nb>0 )
    {
        $prob = kf_betai($nb, $na + 1, 1 - $exp);
    }
    elsif ( $na + $nb > 0 )
    {
        if ( $exp != 0.5 ) { die("Two tailed test is supported only for the symmetrical case (p=0.5)\n"); }
        $prob = ($na > $nb) ? 2*kf_betai($na, $nb + 1, $exp) : 2*kf_betai($nb, $na + 1, $exp);
        if ( $prob > 1 ) { $prob = 1; }
    }

    if ( $args{debug} )
    {
        my @x = `R --slave -e 'binom.test(c($na,$nb),p=$exp,a="$alt")\$p.value'`;
        $x[0] =~ s/^\S+\s*//;
        chomp($x[0]);
        printf "%e\t$prob\t$x[0]\t$na\t$nb\n", abs($x[0]-$prob);
    }
    return $prob;
}

#--------------------------------
package FisherExact;

# Accuracy of this implementation compared to R:
#   avg diff = 6.9e-9
#   std_dev  = 1.3e-8
#   max_diff = 5.0e-8

use strict;
use warnings;
use Carp;
use POSIX;

sub FisherExact::lbinom
{
    my ($n,$k) = @_;
    if ( $k == 0 || $n == $k ) { return 0; }
    return POSIX::lgamma($n+1) - POSIX::lgamma($k+1) - POSIX::lgamma($n-$k+1);
}
sub FisherExact::hypergeo
{
    my ($n11,$n1_,$n_1,$n) = @_;
    return exp(FisherExact::lbinom($n1_, $n11) + FisherExact::lbinom($n-$n1_, $n_1-$n11) - FisherExact::lbinom($n, $n_1));
}
sub FisherExact::hypergeo_acc
{
    my ($n11,$n1_,$n_1,$n,$aux) = @_;
    if ( $n1_ || $n_1 || $n )
    {
        $$aux{n11} = $n11;
        $$aux{n1_} = $n1_;
        $$aux{n_1} = $n_1;
        $$aux{n}   = $n;
    }
    else
    {
        # then only n11 changed; the rest fixed
        if ( $n11 % 11 && $n11 + $$aux{n} - $$aux{n1_} - $$aux{n_1} )
        {
            if ( $n11 == $$aux{n11} + 1)
            {
                # incremental
                $$aux{p}  *= ($$aux{n1_} - $$aux{n11}) / $n11 * ($$aux{n_1} - $$aux{n11}) / ($n11 + $$aux{n} - $$aux{n1_} - $$aux{n_1});
                $$aux{n11} = $n11;
                return $$aux{p};
            }
            if ( $n11 == $$aux{n11} - 1 )
            {
                # incremental
                $$aux{p}  *= $$aux{n11} / ($$aux{n1_} - $n11) * ($$aux{n11} + $$aux{n} - $$aux{n1_} - $$aux{n_1}) / ($$aux{n_1} - $n11);
                $$aux{n11} = $n11;
                return $$aux{p};
            }
        }
        $$aux{n11} = $n11;
    }
    $$aux{p} = FisherExact::hypergeo($$aux{n11}, $$aux{n1_}, $$aux{n_1}, $$aux{n});
    return $$aux{p};
}

sub FisherExact::test
{
    my ($prob,$n11,$n12,$n21,$n22) = @_;

    my $n1_ = $n11 + $n12;
    my $n_1 = $n11 + $n21;
    my $n   = $n11 + $n12 + $n21 + $n22;

    my $max = ($n_1 < $n1_) ? $n_1 : $n1_;  # max n11, for right tail
    my $min = $n1_ + $n_1 - $n;             # not sure why n11-n22 is used instead of min(n_1,n1_)
    if ( $min < 0 ) { $min = 0; }           # min n11, for left tail
    %$prob = ( two=>1, left=>1, right=>1 );
    if ( $min == $max ) { return $prob; }   # no need to test

    my $aux = {};
    my $q = FisherExact::hypergeo_acc($n11, $n1_, $n_1, $n, $aux);   # the probability of the current table

    if ( $q == 0.0 )
    {
        #  If here, the calculated probablility is so small it can't be stored
        #  in a double, which is possible when the table contains fairly large
        #  numbers.  If this happens, most of the calculation can be skipped
        #  as 'left', 'right' and '*two' will be (to a good approximation) 0.0.
        #  The returned values '*_left' and '*_right' depend on which side
        #  of the hypergeometric PDF 'n11' sits.  This can be found by
        #  comparing with the mode of the distribution, the formula for which
        #  can be found at:
        #  https://en.wikipedia.org/wiki/Hypergeometric_distribution
        #  Note that in the comparison we multiply through by the denominator
        #  of the mode (n + 2) to avoid a division.
        if ( $n11 * ($n + 2) < ($n_1 + 1) * ($n1_ + 1))
        {
            # Peak to right of n11, so probability will be lower for all
            # of the region from min to n11 and higher for at least some
            # of the region from n11 to max; hence abs(i-n11) will be 0,
            # abs(j-n11) will be > 0 and:
            %$prob = ( two=>0, left=>0, right=>1 );
            return 0.0;
        }
        else
        {
            # Peak to left of n11, so probability will be lower for all
            # of the region from n11 to max and higher for at least some
            # of the region from min to n11; hence abs(i-n11) will be > 0,
            # abs(j-n11) will be 0 and:
            %$prob = ( two=>0, left=>1, right=>0 );
            return 0.0;
        }
    }

    # left tail
    my $p = FisherExact::hypergeo_acc($min, 0, 0, 0, $aux);
    my ($left,$i);
    for ($left = 0., $i = $min + 1; $p < 0.99999999 * $q && $i<=$max; $i++)     # loop until underflow
    {
        $left += $p, $p = FisherExact::hypergeo_acc($i, 0, 0, 0, $aux);
    }
    $i--;
    if ( $p < 1.00000001 * $q ) { $left += $p; }
    else { $i--; }

    # right tail
    $p = FisherExact::hypergeo_acc($max, 0, 0, 0, $aux);
    my ($right,$j);
    for ($right = 0., $j = $max - 1; $p < 0.99999999 * $q && $j>=0; $j--)   # loop until underflow
    {
        $right += $p, $p = FisherExact::hypergeo_acc($j, 0, 0, 0, $aux);
    }
    $j++;
    if ( $p < 1.00000001 * $q ) { $right += $p; }
    else { $j++; }

    # two-tail
    $$prob{two} = $left + $right;
    if ( $$prob{two} > 1. ) { $$prob{two} = 1.; }

    # adjust left and right
    if ( abs($i - $n11) < abs($j - $n11) ) { $right = 1. - $left + $q; }
    else { $left  = 1.0 - $right + $q; }
    $$prob{left}  = $left;
    $$prob{right} = $right;

    return $q;
}

sub FisherExact::two_sided
{
    my ($n11,$n12,$n21,$n22) = @_;
    my $prob = {};
    FisherExact::test($prob,$n11,$n12,$n21,$n22);
    return $$prob{two};
}

